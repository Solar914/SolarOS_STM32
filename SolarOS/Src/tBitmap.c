/*
*********************************************************************************************************
*
*	模块名称   :   位图数据结构模块。
*	文件名称   :   tBitmap.c
*	版    本   :   V1.0
*	说    明   :   位图数据结构主要用于支持查找最高优先级的任务，即在32
*                位数据中，从第0位开始，查找最先被置1的是第几位
*
*	修改记录   :
*		             版本号     日期         作者            说明
*		              V1.0    2019-4-16      Solar           第一次版本发布
*		              
*
*	版权       ：  仅限学习交流使用，禁止用于商业用途
*
*********************************************************************************************************
*/

#include "tBitmap.h"

/*定义快查表格，在0-255之间任意输入一个数字，即可返回第一位为1的下标*/
static const uint8_t quickFindTable[] =     
{
		/* 00 */ 0xff, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 10 */ 4,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 20 */ 5,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 30 */ 4,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 40 */ 6,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 50 */ 4,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 60 */ 5,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 70 */ 4,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 80 */ 7,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* 90 */ 4,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* A0 */ 5,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* B0 */ 4,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* C0 */ 6,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* D0 */ 4,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* E0 */ 5,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
		/* F0 */ 4,    0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};

/*
*********************************************************************************************************
*	函 数 名  :   tBitmapInit
*	功能说明  :   将位图数据结构变量的值初始化为0
*	形    参  :   tbitmap：位图变量
*	返 回 值  :   无
*********************************************************************************************************
*/
void tBitmapInit(tBitmap *tbitmap)
{
	tbitmap->tbitmap = 0;
}

/*
*********************************************************************************************************
*	函 数 名  :   tBitmapSet
*	功能说明  :   将位图数据结构变量的指定下标的值置1
*	形    参  :   tbitmap：位图变量
                pos：指定位置
*	返 回 值  :   无
*********************************************************************************************************
*/
void tBitmapSet(tBitmap *tbitmap, uint8_t pos)
{
	tbitmap->tbitmap |= (1<<pos);
}

/*
*********************************************************************************************************
*	函 数 名  :   tBitmapReset
*	功能说明  :   将位图数据结构变量的指定下标的值置0
*	形    参  :   tbitmap：位图变量
                pos：指定位置
*	返 回 值  :   无
*********************************************************************************************************
*/
void tBitmapReset(tBitmap *tbitmap, uint8_t pos)
{
	tbitmap->tbitmap &= ~(1<<pos);
}

/*
*********************************************************************************************************
*	函 数 名  :   tBitmapGetFirstSet
*	功能说明  :   将位图变量按照8位长度为一组，分成4组，放入快查表中，返回第1位为1的值的下标
*	形    参  :   tbitmap：位图变量
*	返 回 值  :   0-31之间的任意数字
*********************************************************************************************************
*/
uint8_t tBitmapGetFirstSet(tBitmap *tbitmap)
{
  /* 
	   00000000 00000000 00000000 00000000
	    第4段    第3段    第2段    第1段
	*/
	
	/*如果数据在第1段*/
	if(tbitmap->tbitmap & 0xff)
	{
		return quickFindTable[tbitmap->tbitmap & 0xff];
	}
	
	/*如果数据在第2段*/
	else if(tbitmap->tbitmap & 0xff00)
	{
		return (quickFindTable[(tbitmap->tbitmap>>8) & 0xff] + 8);
	}
	
	/*如果数据在第3段*/
	else if(tbitmap->tbitmap & 0xff0000)
	{
		return (quickFindTable[(tbitmap->tbitmap>>16) & 0xff] + 16);
	}
	
	/*如果数据在第4段*/
	else if(tbitmap->tbitmap & 0xff000000)
	{
		return (quickFindTable[(tbitmap->tbitmap>>24) & 0xff] + 24);
	}
	
	/*如果数据全为0*/
	else
	{
		return tBitmapPosLen();
	}
	
}

/*
*********************************************************************************************************
*	函 数 名  :   tBitmapPosLen
*	功能说明  :   返回位图数据结构算法所支持的最大数据长度
*	形    参  :   无
*	返 回 值  :   位图变量支持的最大长度32
*********************************************************************************************************
*/
uint8_t tBitmapPosLen(void)
{
	return 32;
}

uint8_t tFirst1Table[256];

/*
*********************************************************************************************************
*	函 数 名  :   tFirst1Process
*	功能说明  :   快查表的计算方法
*	形    参  :   p:指向快查表
*	返 回 值  :   无
*********************************************************************************************************
*/
void tFirst1Process(uint8_t *p)
{
	
	/*
	位图数据结构算法：任意一个最大为32位的数据，从最低位开始，第一位为1的位是第几位？
	将32位数据分为4段，每段8位，在8位数据中，求出0-255每个数的第一位为1的位是第几
	位？建立表格（数组），后续输入数据可以直接在表中查找(0-7)，若数据为16位，则+8，若
	数据为24位，则+16，若数据为32位，则+24
	*/
	
	uint8_t i = 0, pos;
	for(i = 0; i <= 255; i++)
	{
		if(i == 0)
		{
			*p = 0xff;

		}
		for(pos = 0; pos < 8; pos++)
		{
			if(i & (1<<pos))
			{
				*p = pos;
				break;
			}
		}
		p++;
	}
}

/***************************** SOLAROS (END OF FILE) *********************************/
